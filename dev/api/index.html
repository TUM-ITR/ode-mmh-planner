<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · OdeMMHPlanner.jl</title><meta name="title" content="API · OdeMMHPlanner.jl"/><meta property="og:title" content="API · OdeMMHPlanner.jl"/><meta property="twitter:title" content="API · OdeMMHPlanner.jl"/><meta name="description" content="Documentation for OdeMMHPlanner.jl."/><meta property="og:description" content="Documentation for OdeMMHPlanner.jl."/><meta property="twitter:description" content="Documentation for OdeMMHPlanner.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="OdeMMHPlanner.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">OdeMMHPlanner.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/sampling/">Inference and Sampler Tuning</a></li><li><a class="tocitem" href="../examples/control/">Optimal Control</a></li></ul></li><li><a class="tocitem" href="../experiments/">Experiments</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Sampling"><span>Sampling</span></a></li><li><a class="tocitem" href="#Analysis-and-Diagnostics"><span>Analysis and Diagnostics</span></a></li><li><a class="tocitem" href="#Optimal-Control"><span>Optimal Control</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><p>This page documents the main functions and types provided by <code>OdeMMHPlanner</code>.</p><h2 id="Sampling"><a class="docs-heading-anchor" href="#Sampling">Sampling</a><a id="Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling" title="Permalink"></a></h2><p>Functions and types related to Bayesian learning of system dynamics and latent state trajectories using the Marginal Metropolis–Hastings (MMH) sampler.</p><article><details class="docstring" open="true"><summary id="OdeMMHPlanner.MMH_sample"><a class="docstring-binding" href="#OdeMMHPlanner.MMH_sample"><code>OdeMMHPlanner.MMH_sample</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>MMH sample</p><p>Fields:</p><ul><li><code>theta</code>: parameters</li><li><code>x_t</code>: state at current time step <span>$t=0$</span></li><li><code>x_init</code>: initial state of the training trajectory, i.e., state at <span>$t=-T$</span>; this is used to adapt the proposal distribution in the staged sampler</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="OdeMMHPlanner.ODE_MMH"><a class="docstring-binding" href="#OdeMMHPlanner.ODE_MMH"><code>OdeMMHPlanner.ODE_MMH</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ODE_MMH(u_t::Function, t_m::AbstractVector{&lt;:AbstractFloat}, y::AbstractMatrix{&lt;:AbstractFloat}, t_span::Tuple{Float64,Float64}, K::Int, K_b::Int, k_d::Int, f_theta!::Function, g_theta!::Function, log_pdf_w_theta::Function, log_pdf_theta::Function, theta_0::AbstractVector{&lt;:AbstractFloat}, log_pdf_x_init::Function, x_init_0::AbstractVector{&lt;:AbstractFloat}, propose_z::Function, log_proposal_ratio_z::Function; ODE_solver=RK4(), ODE_solver_opts=(dt=0.1, adaptive=false), print_progress=true)</code></pre><p>Run marginal Metropolis-Hastings (MMH) with ODE-integrated latent trajectory to obtain samples <span>$\{\theta, x(t=0)\}^{[1:K]}$</span> from the joint parameter and state posterior distribution <span>$p(\theta, x(t=0) \mid \mathbb{D}=\{u(t), y_{1:M}\})$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>u_t</code>: input trajectory; function of time <span>$t$</span></li><li><code>t_m</code>: time points of the output measurements, must lie within <code>t_span</code></li><li><code>y</code>: output measurements</li><li><code>t_span</code>: timespan of the training trajectory</li><li><code>K</code>: number of models/scenarios to be sampled</li><li><code>K_b</code>: length of the burn in period</li><li><code>k_d</code>: number of models/scenarios to be skipped to decrease correlation (thinning)</li><li><code>f_theta!</code>: dynamics function parametrized by theta (mutating); has inputs <span>$(\dot{x}, \theta, x, u, t)$</span></li><li><code>g_theta!</code>: measurement function parametrized by theta (mutating); has inputs <span>$(g, \theta, x, u, t)$</span></li><li><code>log_pdf_w_theta</code>: function that returns the logarithm of the probability density function of the measurement noise parametrized by theta; has inputs <span>$(\theta, w)$</span></li><li><code>log_pdf_theta</code>: function that returns the logarithm of the probability density function of theta (prior); has input <span>$(\theta)$</span></li><li><code>theta_0</code>: <span>$\theta$</span> used to initialize the MMH sampler</li><li><code>log_pdf_x_init</code>: function that returns the logarithm of probability density function of <span>$x(t=-T)$</span> (prior); has input <span>$x(t=-T)$</span></li><li><code>x_init_0</code>: <span>$x(t=-T)$</span> used to initialize the MMH sampler</li><li><code>propose_z</code>: function that proposes new parameters <span>$z&#39; = [\theta&#39;; x&#39;(t=-T)]$</span> (proposal distribution); has input (<span>$z = [\theta; x(t=-T)$</span>])</li><li><code>log_proposal_ratio_z</code>: function that computes the logarithm of the ratio of proposal densities for <span>$z$</span>; has input arguments <span>$(z, z&#39;)$</span></li><li><code>ODE_solver</code>: ODE solver algorithm to use (we use RK4 as default as this is also used in the optimal control formulation)</li><li><code>ODE_solver_opts</code>: ODE solver setting</li><li><code>print_progress</code>: if true, the progress is printed (default: <code>true</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>MMH_samples</code>: MMH samples</li><li><code>acceptance_ratio</code>: acceptance ratio of the MMH sampler</li><li><code>runtime</code>: runtime of the sampling process</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="OdeMMHPlanner.staged_ODE_MMH"><a class="docstring-binding" href="#OdeMMHPlanner.staged_ODE_MMH"><code>OdeMMHPlanner.staged_ODE_MMH</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">staged_ODE_MMH(u_t::Function, t_m::AbstractVector{&lt;:AbstractFloat}, y::AbstractMatrix{&lt;:AbstractFloat}, t_span::Tuple{Float64,Float64}, K::Int, K_b::Int, k_d::Int, f_theta!::Function, g_theta!::Function, log_pdf_w_theta::Function, log_pdf_theta::Function, theta_0::AbstractVector{&lt;:AbstractFloat}, log_pdf_x_init::Function, x_init_0::AbstractVector{&lt;:AbstractFloat}, proposal_z_cov_0::AbstractMatrix{&lt;:AbstractFloat}, M_chunk::Int, K_stage::Int, alpha::Union{AbstractFloat,AbstractVector{&lt;:AbstractFloat}}; regularizer::Float64=1e-8, ODE_solver=RK4(), ODE_solver_opts=(dt=0.1, adaptive=false), print_progress=true)</code></pre><p>Run marginal Metropolis-Hastings (MMH) with ODE-integrated latent trajectory with incremental data and adaptive proposal to obtain samples <span>$\{\theta, x(t=0)\}^{[1:K]}$</span> from the joint parameter and state posterior distribution <span>$p(\theta, x(t=0) \mid \mathbb{D}=\{u(t), y_{1:M}\})$</span>. The number of data points used in the likelihood computation is gradually increased by a fixed chunk size. At each stage, the MMH sampler is run on the current data subset, and the proposal distribution is adapted based on the empirical covariance of the collected samples.</p><p><strong>Arguments</strong></p><ul><li><code>u_t</code>: input trajectory; function of time <span>$t$</span></li><li><code>t_m</code>: time points of the output measurements, must lie within <code>t_span</code></li><li><code>y</code>: output measurements</li><li><code>t_span</code>: timespan of the training trajectory</li><li><code>K</code>: number of models/scenarios to be sampled</li><li><code>K_b</code>: length of the burn in period</li><li><code>k_d</code>: number of models/scenarios to be skipped to decrease correlation (thinning)</li><li><code>f_theta!</code>: dynamics function parametrized by theta (mutating); has inputs <span>$(\dot{x}, \theta, x, u, t)$</span></li><li><code>g_theta!</code>: measurement function parametrized by theta (mutating); has inputs <span>$(g, \theta, x, u, t)$</span></li><li><code>log_pdf_w_theta</code>: function that returns the logarithm of the probability density function of the measurement noise parametrized by theta; has inputs <span>$(\theta, w)$</span></li><li><code>log_pdf_theta</code>: function that returns the logarithm of the probability density function of theta (prior); has input <span>$(\theta)$</span></li><li><code>theta_0</code>: <span>$\theta$</span> used to initialize the MMH sampler</li><li><code>log_pdf_x_init</code>: function that returns the logarithm of probability density function of <span>$x(t=-T)$</span> (prior); has input <span>$x(t=-T)$</span></li><li><code>x_init_0</code>: <span>$x(t=-T)$</span> used to initialize the MMH sampler</li><li><code>proposal_z_cov_0</code>: initial covariance of the multivariate normal proposal distribution for <span>$z = [\theta; x(t=-T)]$</span> (e.g., covariance of the prior)</li><li><code>M_chunk</code>: number of data points added at each stage</li><li><code>K_stage</code>: number of samples per stage</li><li><code>alpha</code>: proposal scaling factor (scalar or vector; if a vector its i‐th element is used at stage i)</li><li><code>regularizer</code>: small constant added to the diagonal of the proposal covariance matrix to ensure positive definiteness (default: <code>1e-8</code>)</li><li><code>ODE_solver</code>: ODE solver algorithm to use (we use RK4 as default as this is also used in the optimal control formulation)</li><li><code>ODE_solver_opts</code>: ODE solver setting</li><li><code>print_progress</code>: if true, the progress is printed (default: <code>true</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>MMH_samples</code>: final samples from full-data posterior</li><li><code>acceptance_ratio</code>: vector containing the acceptance ratio of each stage</li><li><code>runtime</code>: total runtime of the staged sampling process</li></ul></div></section></details></article><h2 id="Analysis-and-Diagnostics"><a class="docs-heading-anchor" href="#Analysis-and-Diagnostics">Analysis and Diagnostics</a><a id="Analysis-and-Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis-and-Diagnostics" title="Permalink"></a></h2><p>Utilities for analyzing and diagnosing the MCMC chains produced by the MMH sampler.</p><article><details class="docstring" open="true"><summary id="OdeMMHPlanner.compute_autocorrelation"><a class="docstring-binding" href="#OdeMMHPlanner.compute_autocorrelation"><code>OdeMMHPlanner.compute_autocorrelation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_autocorrelation(MMH_samples::Vector{MMH_sample}; max_lag::Int=100)</code></pre><p>Compute the autocorrelation function (ACF) of the MMH samples.</p><p><strong>Arguments</strong></p><ul><li><code>MMH_samples</code>: MMH samples</li><li><code>max_lag</code>: maximum lag at which to calculate the ACF</li></ul><p><strong>Returns</strong></p><ul><li><code>autocorrelation</code>: matrix containing the ACF for each variable</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="OdeMMHPlanner.compute_ess"><a class="docstring-binding" href="#OdeMMHPlanner.compute_ess"><code>OdeMMHPlanner.compute_ess</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_ess(MMH_samples::Vector{MMH_sample}; max_lag::Int=100)</code></pre><p>Compute the effective sample size (ESS) for each parameter and initial state.</p><p><strong>Arguments</strong></p><ul><li><code>MMH_samples</code>: MMH samples</li><li><code>max_lag</code>: maximum lag for autocorrelation estimation</li></ul><p><strong>Returns</strong></p><ul><li><code>ess</code>: vector of ESS estimates for all variables</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="OdeMMHPlanner.compute_gelman_rubin"><a class="docstring-binding" href="#OdeMMHPlanner.compute_gelman_rubin"><code>OdeMMHPlanner.compute_gelman_rubin</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_gelman_rubin(MMH_chains::Vector{Vector{MMH_sample}})</code></pre><p>Compute the Gelman–Rubin statistic for each parameter and initial state from a vector of MMH chains.</p><p><strong>Arguments</strong></p><ul><li><code>MMH_chains</code>: vector of chains, where each chain is a vector of MMH samples</li></ul><p><strong>Returns</strong></p><ul><li><code>R_hat</code>: vector of R̂ values, one for each variable</li></ul></div></section></details></article><h2 id="Optimal-Control"><a class="docs-heading-anchor" href="#Optimal-Control">Optimal Control</a><a id="Optimal-Control-1"></a><a class="docs-heading-anchor-permalink" href="#Optimal-Control" title="Permalink"></a></h2><p>Functions for formulating and solving the scenario-based optimal control problem using posterior samples obtained from MMH.</p><article><details class="docstring" open="true"><summary id="OdeMMHPlanner.solve_MMH_OCP"><a class="docstring-binding" href="#OdeMMHPlanner.solve_MMH_OCP"><code>OdeMMHPlanner.solve_MMH_OCP</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">solve_MMH_OCP(MMH_samples::Vector{MMH_sample}, n_u::Int, f_theta::Function, g_theta::Function, H::Float64, N::Int, c::Function, c_f::Function, h_scenario::Function, h_u::Function; U_init=nothing, MMH_samples_pre_solve=nothing, K_warmup=0, solver_opts=nothing, rk4_step_size=0.1, print_progress=true)</code></pre><p>Solve the continous time scenario optimal control problem of the following form:</p><p><span>$\min_{u(\cdot)} J_{sc}(u(\cdot)) := \frac{1}{K} \sum_{k=1}^{K} [ c_f(x^{[k]}(H)) + \int_0^H c(u(t), x^{[k]}(t), t) dt],$</span></p><p>subject to: </p><p class="math-container">\[\begin{aligned}
\forall t \in [0,H], \forall k  \in \mathbb{N}_{\leq K}, \\
x^{[k]}(t) = \Phi(t; \theta^{[k]}, x^{[k]}(0), u(\cdot)), \\
h_{scenario}(u(t), x^{[k]}(t), t) \leq 0.
\end{aligned}\]</p><p>Here, <span>$\Phi(t; \theta^{[k]}, x^{[k]}(0), u(\cdot))$</span> denotes the solution at time <span>$t$</span> of the ODE <span>$\dot{x}(t) = f_{\theta}(x(t), u(t))$</span> with initial condition <span>$x(0) = x^{[k]}(0)$</span> and parameter <span>$\theta$</span> under the input trajectory <span>$u(\cdot)$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>MMH_samples</code>: MMH samples</li><li><code>n_u</code>: number of control inputs</li><li><code>f_theta</code>: dynamics function parametrized by theta (non mutating); has inputs <span>$(\theta, x, u, t)$</span></li><li><code>g_theta</code>: measurement function parametrized by theta (non mutating); has inputs <span>$(\theta, x, u, t)$</span></li><li><code>H</code>: horizon of the OCP (as time)</li><li><code>N</code>: number of discretization steps in the horizon</li><li><code>c</code>: function with input arguments <span>$(u(t), x^{[k]}(t), t)$</span> that returns the running cost of scenario k at time t</li><li><code>c_f</code>: function with input argument <span>$x^{[k]}(H)$</span> that returns the terminal cost of scenario k</li><li><code>h_scenario</code>: function with input arguments <span>$(u(t), x^{[k]}(t), t)$</span> that returns the constraint vector for scenario k at time t; a feasible solution must satisfy <span>$h_{\mathrm{scenario}} \leq 0$</span> for all scenarios and all discretization points</li><li><code>h_u</code>: function with input arguments <span>$(u(t), t)$</span> that returns the constraint vector for the control inputs; a feasible solution satisfy <span>$h_u \leq 0$</span> at all discretization points</li><li><code>U_init</code>: initial guess for the input trajectory - either a <code>n_u x N</code> array, a function with input argument t, or nothing (default: nothing)</li><li><code>MMH_samples_pre_solve</code>: if provided, an initial guess for the input trajectory is obtained by solving an OCP with the samples in <code>MMH_samples_pre_solve</code> only</li><li><code>K_warmup</code>: if <code>K_warmup &gt; 0</code> and <code>MMH_samples_pre_solve</code> is provided, an initial guess for the the input trajectory is obtained in a two stage process: first, an OCP with only <code>K_warmup</code> samples from <code>MMH_samples_pre_solve</code> is solved and then an OCP with all samples in <code>MMH_samples_pre_solve</code></li><li><code>solver_opts</code>: SolverOptions struct containing options of the solver</li><li><code>rk4_step_size</code>: step size of the RK4 integrator used to simulate the system dynamics</li><li><code>print_progress</code>: if set to true, the progress is printed</li></ul><p><strong>Returns</strong></p><ul><li><code>U_opt</code>: piecewise constant optimal input trajectory, array of dimension <code>n_u x N</code></li><li><code>X_opt</code>: states at the discretization points for all scenarios, array of dimension <code>n_x x N x K</code></li><li><code>t_grid</code>: time grid of the discretization points, array of dimension <code>N + 1</code></li><li><code>J_sc_opt</code>: optimal cost <span>$J_{sc}$</span></li><li><code>solve_successful</code>: true if the optimization was successful, false otherwise</li><li><code>iterations</code>: number of iterations of the solver</li><li><code>runtime</code>: runtime of the optimization</li></ul></div></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../experiments/">« Experiments</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 7 January 2026 19:04">Wednesday 7 January 2026</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
