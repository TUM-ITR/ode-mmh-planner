# This script analyzes the results of a Monte-Carlo simulation generated by `run_montecarlo_slurm.sh`.
# It aggregates metrics over multiple runs and plots trajectories for selected seeds.

using JLD2
using Statistics
using Plots
using Printf
using Logging
using OdeMMHPlanner

# Define the directory containing the results to analyze and the seeds to plot.
const RESULTS_DIR = joinpath(@__DIR__, "results", "job_1368") # adjust as needed
seeds_to_plot = [40] # plot results for these seeds

# Meal disturbance
struct Meal
    t_meal::Float64   # time of meal     min
    size::Float64     # glucose intake   mg/dL
end

# This function loads all .jld2 result files from the given directory.
function load_all_results(results_dir::AbstractString)
    files = filter(f -> endswith(f, ".jld2"), readdir(results_dir; join=true))
    sort!(files)

    results = Any[]
    seeds = Int[]
    with_logger(NullLogger()) do
        for file in files
            result = load(file, "result")
            push!(results, result)
            push!(seeds, result.seed)
        end
    end

    @printf("Loaded %d result files from %s\n", length(results), results_dir)

    return seeds, results
end

# This function aggregates metrics over multiple runs and prints summary statistics.
function aggregate_metrics(seeds::Vector{Int}, results::Vector{Any})
    n = length(results)

    @printf("Aggregating metrics from %d runs\n", n)

    # Collect costs.
    J_true_MMH = Float64[]
    J_true_nom = Float64[]
    J_true_no_control = Float64[]
    J_true_bolus = Float64[]

    # Constraint satisfaction flags (per seed)
    h_scenario_MMH = Bool[]
    h_u_MMH = Bool[]
    h_scenario_nom = Bool[]
    h_u_nom = Bool[]
    h_scenario_no_control = Bool[]
    h_u_no_control = Bool[]
    h_scenario_bolus = Bool[]
    h_u_bolus = Bool[]

    # Track how many scenario/nominal solves were successful.
    n_MMH_success = 0
    n_nom_success = 0

    for (seed, r) in zip(seeds, results)
        # Proposed method
        if r.solve_successful_MMH
            n_MMH_success += 1
            push!(J_true_MMH, r.J_true_MMH)
            push!(h_scenario_MMH, r.h_scenario_satisfied_MMH)
            push!(h_u_MMH, r.h_u_satisfied_MMH)
        else
            @warn "Scenario solve not successful for seed $seed. Skipping results for this seed."
        end

        # Nominal model based optimal control
        if r.solve_successful_nom
            n_nom_success += 1
            push!(J_true_nom, r.J_true_nom)
            push!(h_scenario_nom, r.h_scenario_satisfied_nom)
            push!(h_u_nom, r.h_u_satisfied_nom)
        else
            @warn "Nominal solve not successful for seed $seed. Skipping results for this seed."
        end

        # No control input
        push!(J_true_no_control, r.J_true_no_control)
        push!(h_scenario_no_control, r.h_scenario_satisfied_no_control)
        push!(h_u_no_control, r.h_u_satisfied_no_control)

        # Simple bolus insulin input
        push!(J_true_bolus, r.J_true_bolus)
        push!(h_scenario_bolus, r.h_scenario_satisfied_bolus)
        push!(h_u_bolus, r.h_u_satisfied_bolus)
    end

    @printf("================ Monte Carlo Summary ================\n")
    @printf("Number of runs loaded:                                     %3d\n", length(results))
    @printf("Number of times the MMH OCP is solved successfully:        %3d\n", n_MMH_success)
    @printf("Number of times the nominal OCP is solved successfully:    %3d\n", n_nom_success)
    @printf("====================================================\n")

    mean_or_nan(v) = isempty(v) ? NaN : mean(v)
    @printf("\n--- Cost (mean ± standard deviation) over successful runs ---\n")
    @printf("MMH-scenario:      %10.1f      ±%10.1f\n", mean_or_nan(J_true_MMH), std(J_true_MMH))
    @printf("Nominal + EKF:     %10.1f      ±%10.1f\n", mean_or_nan(J_true_nom), std(J_true_nom))
    @printf("No Control:        %10.1f      ±%10.1f\n", mean(J_true_no_control), std(J_true_no_control))
    @printf("Bolus input:       %10.1f      ±%10.1f\n", mean(J_true_bolus), std(J_true_bolus))

    # Helper: violation count and ratio
    function count_violations(flags::Vector{Bool})
        n = length(flags)
        n == 0 && return (0, 0.0)
        n_ok = count(identity, flags)
        n_violated = n - n_ok
        ratio = n_violated / n
        return n_violated, ratio
    end

    @printf("\n--- Constraint violations ---\n")
    n_v, r = count_violations(h_scenario_MMH)
    @printf("MMH-scenario (state constraints):           %3d / %3d (%.1f %%)\n", n_v, length(h_scenario_MMH), 100 * r)
    n_v, r = count_violations(h_u_MMH)
    @printf("MMH-scenario (input constraints):           %3d / %3d (%.1f %%)\n", n_v, length(h_u_MMH), 100 * r)
    n_v, r = count_violations(h_scenario_nom)
    @printf("Nominal + EKF (state constraints): %3d / %3d (%.1f %%)\n", n_v, length(h_scenario_nom), 100 * r)
    n_v, r = count_violations(h_u_nom)
    @printf("Nominal + EKF (input constraints): %3d / %3d (%.1f %%)\n", n_v, length(h_u_nom), 100 * r)
    n_v, r = count_violations(h_scenario_no_control)
    @printf("No control (state constraints):        %3d / %3d (%.1f %%)\n", n_v, length(h_scenario_no_control), 100 * r)
    n_v, r = count_violations(h_u_no_control)
    @printf("No control (input constraints):        %3d / %3d (%.1f %%)\n", n_v, length(h_u_no_control), 100 * r)
    n_v, r = count_violations(h_scenario_bolus)
    @printf("Bolus input (state constraints):       %3d / %3d (%.1f %%)\n", n_v, length(h_scenario_bolus), 100 * r)
    n_v, r = count_violations(h_u_bolus)
    @printf("Bolus input (input constraints):       %3d / %3d (%.1f %%)\n", n_v, length(h_u_bolus), 100 * r)
    println("====================================================\n")
end

# This function plots predictions and true trajectories for a single run.
function plot_single_run(result; states_to_plot=[1])
    # Extract data from result.
    X_MMH = result.X_MMH
    t_grid = result.t_grid
    x_true_MMH = result.x_true_MMH
    x_true_nom = result.x_true_nom
    x_true_no_control = result.x_true_no_control
    x_true_bolus = result.x_true_bolus
    t_pred = result.t_pred

    # Constraints
    G_MIN = 70.0
    G_MAX = 180.0

    x_min_constraint = G_MIN * ones(1, length(t_pred))
    x_max_constraint = G_MAX * ones(1, length(t_pred))

    for i in states_to_plot
        # Calculate mean, maximum, and minimum prediction.
        x_pred_mean = mean(X_MMH, dims=3)[i, :, 1]
        x_pred_max = maximum(X_MMH, dims=3)[i, :, 1]
        x_pred_min = minimum(X_MMH, dims=3)[i, :, 1]

        # Plot scenarios.
        p = plot(t_grid, x_pred_min, fillrange=x_pred_max, alpha=0.35, label="MMH (scenarios)", legend=:topright)

        # Plot mean prediction.
        plot!(t_grid, x_pred_mean, label="MMH (mean)", lw=2)

        # Plot true output.
        plot!(t_pred, x_true_MMH[i, :], label="MMH (realized)", lw=2)

        # Plot trajectory of nominal OCP for comparison.
        plot!(t_pred, x_true_nom[i, :], label="Nominal (realized)", lw=2, ls=:dashdot)

        # Plot trajectory of prior OCP for comparison.
        # plot!(t_pred, x_true_prior[i, :], label="Prior (realized)", lw=2, ls=:dashdotdot)

        # Plot trajectory without control for comparison.
        plot!(t_pred, x_true_no_control[i, :], label="No control (realized)", lw=2, ls=:dash)

        # Plot trajectory with bolus input for comparison.
        plot!(t_pred, x_true_bolus[i, :], label="Bolus (realized)", lw=2, ls=:dot)
        # Plot the constraints.
        plot!(t_pred, x_min_constraint[i, :], fillrange=x_min_constraint[i, :] .- 10, linecolor=:red, fillcolor=:red, alpha=0.35, label="Safety bounds")
        plot!(t_pred, x_max_constraint[i, :], fillrange=x_max_constraint[i, :] .+ 10, linecolor=:red, fillcolor=:red, alpha=0.35, label="")

        title!("\$x_{$i}\$: trajectories over time")
        ylabel!("\$x_{$i}\$")
        xlabel!("\$t\$")
        display(p)
    end
end

# This function loads and plots trajectories for the given seeds.
function plot_seeds(results_dir::AbstractString, seeds_to_plot::Vector{Int}; states_to_plot=[1])
    for s in seeds_to_plot
        file = joinpath(results_dir, "results_seed_$(s).jld2")
        if !isfile(file)
            @warn "Result file for seed $s not found at $file"
            continue
        end
        result = nothing
        with_logger(NullLogger()) do
            result = load(file, "result")
        end
        plot_single_run(result; states_to_plot=states_to_plot)
    end
end

if !isdir(RESULTS_DIR)
    error("RESULTS_DIR does not exist: $RESULTS_DIR")
end

seeds, results = load_all_results(RESULTS_DIR)
aggregate_metrics(seeds, results)

# Plot results for the specified seeds.
plot_seeds(RESULTS_DIR, seeds_to_plot; states_to_plot=[1])